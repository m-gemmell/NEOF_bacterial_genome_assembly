---
title: "Bacterial genome assembly and annotation"
author: "Matthew R. Gemmell"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
favicon: figures/NEOF_favicon.png
description: NEOF book for the Bacterial genome assembly and annotation workshop
cover-image: "figures/NEOF.png"
---

```{r, fig.align = 'center',out.width= '30%', echo=FALSE }
knitr::include_graphics(path = "figures/NEOF.png", auto_pdf = TRUE)
```

# (PART\*) Start {-}
# Introduction

```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/map.png", auto_pdf = TRUE)
```

This practical session will run you through a standard bacterial genome assembly and annotation workflow using PacBio data. The topics covered are:

- [Setup](#setup)
- [Overview](#overview)
- [Genome assembly with `Redbean` (`wtdbg2`)](#redbeanassembly)
- [Assembly assessment](#genomeassemblyassessment)
- [Polishing with `arrow`](#polishing)
- [Circularisation with `Circlator`](#Circlator)
- [Annotation with `Prokka`](#annotation)
- [Final report generation with `MultiQC`](#finalreport)

The aim of this practical is to produce a genome assembly of _Eschrichia coli_, annotate it, and produce a report with the assembly's stats. Read QC will be skipped as this has been covered in a previous NEOF workshop.

Commands are in the following font, colour, and box.They should be run in the command line.

```{bash eval=FALSE}
echo "This is a command example" 
```

<!--chapter:end:01-Bacterial_genome_assembly_and_annotation.Rmd-->

# Cluster Introduction
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/cluster.png", auto_pdf = TRUE)
``` 

## Logon instructions
For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent.

You will now be in a logged-in Linux VNC desktop. You will see something as below (there may be only one terminal which is fine). If you do not see something similar please ask for assistance.

```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/logon_pic.png", auto_pdf = TRUE)
``` 

If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. Ensure you can see one whole terminal.

These instructions will not work outside of this workshop. If you would like to install your own Linux OS on your desktop or laptop we would recommend Ubuntu. 

The following link is a guide to install Ubuntu:  
https://www.ubuntu.com/download/desktop/install-ubuntu-desktop.  
If you use a USB you need to create a bootable USB stick. The following link will assist:  
https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows 

## The Terminal Window
In our case the terminal window looks like the picture below. We are using the terminal window as our shell to interpret our commands to the kernel. Depending on your system and preferences it may look different.
```{r, fig.align = 'center',out.width= '80%', echo=FALSE }
knitr::include_graphics(path = "figures/terminal_window.png", auto_pdf = TRUE)
``` 

Already there is useful information for us on the terminal window.

- __nsc065__: This is the login name, also known as the username. In this case nsc065 is a demonstrator's account. Your screen should show a different account name which will be your username for the Linux machine/cluster you are logged into.
- __gauss03__: This is the machine name the user is logged into.
- __\~__: This represents the current directory of the user, or the directory a command was run in. In the Linux OS and others __'~'__ is a shortcut to the user's home directory.
- Everything after the __'$'__ is where commands are typed into the terminal. This is also referred to as the command line.

__To open a new terminal window__, right click on the main screen, choose `Applications` -> `Shell` -> `bash`

<!--chapter:end:02-Cluster_Introduction.Rmd-->

# (PART\*) Standard workflow {.unnumbered}

# Setup {#setup}

```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/start.png", auto_pdf = TRUE)
```

## Workshop directory & data

Prior to starting analysis we will create a working directory. The directory `~/bacterial_assembly/standard_workflow` will contain all the inputs and outputs of our analyses.

```{bash eval=FALSE}
#Make directory
mkdir -p ~/bacterial_assembly/standard_workflow
#Move into it
cd ~/bacterial_assembly/standard_workflow
```

During the workflow we will keep a tidy directory structure outputting the results form different tools into their respective directories.

For the standard workflow we will be using pre QC'd PacBio reads of an *Escherichia coli* genome. Create a directory and create soft links (i.e. a shortcut) of the read data.

```{bash eval=FALSE}
#Create directory
mkdir ecoli_reads
#Softlink of read data
ln -s /pub39/tea/nsc006/NEOF/bact_assembly/data/ecoli.fastq ecoli_reads
```

## Conda environments

```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/conda.png", auto_pdf = TRUE)
```

`Conda` is a very useful tool for bioinformaticians. It allows for the creation of virtual environments so you can install different programs. This is generally easier than manually installing programs for 2 main reasons:

-   __Normally__ `Conda` will install all the dependencies a program needs.
    -   Prior to `Conda` it could take more than a day to install a program and all its dependencies plus the dependencies of the dependencies etc.
-   Different programs may need different versions of the same program as a dependency (e.g. One program may need Python2 whilst another needs Python3). Therefore installing one can break the other. Having separate `Conda` environments (virtual environments) can isolate clashing programs.

**Analogy**: You can think of programs as food and environments as food storage units. You could try to shove all your food into one giant cold room but most of your food will either be too cold or too warm. Instead it would be better to have different types of food in different environments as outlined in the below table.

| Storage environment | Food examples                      |
|---------------------|------------------------------------|
| Fridge              | Fresh vegetables, fresh meat, etc. |
| Freezer             | Frozen meat, ice, etc.             |
| Pantry              | Canned food, jarred food, etc.     |
| Cellar              | Wine.                              |
| Fruit bowl          | Fruit.                             |

As we will be using many different programs we will be using different `Conda` environments. To activate these environments you will be using `use` scripts that will activate the relevant `Conda` environment belonging to user `nsc006` (Matthew Gemmell).

Preferably during the course of this workflow you will have a terminal open for each `Conda` environment. It is important to make sure you are in the correct terminal/environment for each chapter. 

You can see what environment a terminal currently has activated by looking at the command prompt. In the below picture we can see the command prompt says we are in the environment called `bacterial_assembly`. The name of the currently activated `Conda` environment will always be in `()` before the login/user name across all systems when using `Conda`.

```{r, fig.align = 'center',out.width= '60%', echo=FALSE }
knitr::include_graphics(path = "figures/conda_bacterial_assembly_terminal.png", auto_pdf = TRUE)
```

For your own future analyses you would use your own `Conda`. If you are interested please see the `Conda` and `Mamba` links in the [Next steps](#nextsteps) section of the Appendix.

<!--chapter:end:03-Start.Rmd-->

# Overview {#overview}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/overview.png", auto_pdf = TRUE)
``` 

## Overview: Bacterial genome assembly

(Specific points about bacterial genome assembly)



## Overview: Long read data

(short versus long read assembly. long read becoming more popular)

(PacBio vs ONT, this standard pipeline will work for ONT with some changes)

## Overview: Read QC

(talk about the read data here and how it was created)

## Overview: Assembly

## Overview: Assembly assessment

## Overview: Polishing

## Overview: Circlator

## Overview: Annotation

## Overview: Final report

<!--chapter:end:04-Overview.Rmd-->

# Genome Assembly {#redbeanassembly}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/string.png", auto_pdf = TRUE)
``` 

The first step of any genome assembly project is to carry out is QC of the read data. The very next step is genome assembly. There are many different assemblers and in the past the choice of assembler and its parameters was the primary task to produce a good quality assembly after getting good quality reads.

The bioinformatician's choice of assembler and parameters is not as vital as it once was. This is due to great improvements to sequencing technologies and bioinformatics processes which include:

- Sequencing technologies are creating longer and higher quality reads.
   - The better the length and quality, the less work assemblers needs to do.
   - There may come a time when you can get one read that perfectly represents an entire genome/chromosome. Assembly would not be required at all.
- Genome assemblers are improving.
   - There is a large choice of good genome assemblers. It is less a question of which to use and more a question of which not to use.
- Genome assembly parameter choice is a smaller issue.
   - For older assemblers and older versions of assemblers it would take a lot of trial and error to try to find the best parameters.
   - Now like many bioinformatics tools, assemblers will attempt to use the best parameters for your data. Generally they are better and quicker than humans at this.

## Redbean
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/redbean.png", auto_pdf = TRUE)
``` 

For assembly of our PacBio reads we will be using `Redbean` (AKA `wtdbg2`). `Redbean` is a long read assembler with comparable performance to others. However, where it excels is its speed,  it is much faster than other long read assemblers. This make it perfect for this workshop.

`Redbean` can be used for genomes of all sizes. It will work for Viruses, Bacteria, Archaea, and Eukaryotes.

`Redbean` works for PacBio RSII, PacBio Sequel, and Oxford nanopore data.

### Redbean: Conda environment & directory
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/conda.png", auto_pdf = TRUE)
``` 

We will use the `bacterial_assembly` `conda` environment for our `Redbean` assembly. This will be our main conda environment for our standard workflow.

Activate the environment:

```{bash eval=FALSE}
. usebacterialassembly
```

Before we start we will move into our analysis directory (created in [setup](#setup)) and create a directory for the assembly we will produce.

```{bash eval=FALSE}
#Change directory to analysis directory
cd ~/bacterial_assembly/standard_workflow
#Create directory for redbean output
mkdir redbean_assembly
```

### Redbean: Assemble long reads
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/assembly_simple.png", auto_pdf = TRUE)
``` 

The first step of `Redbean` is to carry out the assembly. This is carried out with the `wtdgb2` command.

```{bash eval=FALSE}
wtdbg2 -x rs -g 4.6m -i ecoli_reads/ecoli.fastq -o redbean_assembly/ecoli -t 8
```

__Parameters__

- `-x` : This indicates the sequencing technology of the input reads.
   - `rs` = PacBio RSII
   - `sq` = PacBio Sequel
   - `ccs` = PacBio CCS reads
   - `ont` = Oxford Nanopore
- `-g` : This indicates the estimated size of the genome
   - This does not need to be super exact with and you ca round up to two significant figures. Examples are below.
      - _E.coli_ | genome size = 4,639,221 bp => `-g 4.6m` (m = megabases)
      - _Phi-X174_ | genome size = 5386 bp => `-g 5.4k` (k = kilobase)
      - _H.Sapiens_ | genome size = 3.2Gb => `-g 3g` (g = gigabase)
- `-i` : The input reads.
- `-o` : The output prefix.
   - With this set to `redbean_assembly/ecoli` all the output files will be in the directory `redbean_assembly` with the prefix `ecoli`.
- `-t` : Number of threads to be used.

The will create a bunch of output files. Most of these we will ignore with only 4 being used below.

### Redbean: Derive consensus
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/consensus.png", auto_pdf = TRUE)
``` 

If you checked the output directory you may have noticed there was no fasta file. Therefore the next step is to create a fasta file that contains the consensus assembly with `wtpoa-cns`.

```{bash eval=FALSE}
wtpoa-cns -t 8 -i redbean_assembly/ecoli.ctg.lay.gz -fo redbean_assembly/ecoli.ctg.fa
```

__Parameters__

- `-i` : The input `ctg.lay.gz` file produced by `wtdbg2`
- `-fo` : The output file path for the consensus assembly in fasta format.
- `-t` : Number of threads to be used.

The consensus is produced from the assembly graph (more on the graph below). Assembly is not always straight forward and when producing a graph, an assembler may derive multiple paths/branches through the assembly. 

Two examples of how this may occur are:

- __Repeating regions__: An assembler may find it hard to determine how many times a repeat occurs within the repeat region. Maybe it is 10 or 11 times.
- __Identical homopolymers__: It is possible that long homopolymers of As (or one of the other bases) occurs multiple times in the genome. It may then be difficult to know what is at either end of each unique homopolymer location. 
   - E.g. There are 2 homopolymer sequences (H1 & H2) with 4 ends (E1-4).
      - Is H1 flanked by E1 and E2 and therefore H2 is flanked by E3 and E4?
      - Or is H1 flanked by E1 and E3 and therefore H2 is flanked by E2 and E4?
      - Etc.

The consensus can then be thought of as the one best path through the graph to produce the most likely genome assembly.

## Bandage Visualisation
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/bandage.png", auto_pdf = TRUE)
``` 

This part is optional and generally something I never do in real analyses. However, it is interesting and will help your understanding of assembly graphs.

`Redbean` carries out 3 iterations of graph construction, each getting better. These three graph iterations are represented by the `.dot.gz` files. We can visualise these graphs with the tool `Bandage`.

Before visualisation we need to convert the files to `.gfa` (link on file specs in [appendix](#manuals)) files which are compatible with `Bandage`.

First we need to `gunzip` the files.

```{bash eval=FALSE}
gunzip redbean_assembly/ecoli.1.dot.gz
gunzip redbean_assembly/ecoli.2.dot.gz
gunzip redbean_assembly/ecoli.3.dot.gz
```

Next we convert the `.dot` files into `.gfa` files.

The script `wtdbg2-dot2gfa.pl` is found in the scripts directory of `wtdbg2` which can be found at: https://github.com/ruanjue/wtdbg2/tree/master/scripts. Unfortunately this is not installed when you install `wtdbg2` via `Conda`.

```{bash eval=FALSE}
wtdbg-dot2gfa.pl redbean_assembly/ecoli.1.dot > redbean_assembly/ecoli.1.dot.gfa
wtdbg-dot2gfa.pl redbean_assembly/ecoli.2.dot > redbean_assembly/ecoli.2.dot.gfa
wtdbg-dot2gfa.pl redbean_assembly/ecoli.3.dot > redbean_assembly/ecoli.3.dot.gfa
```

Now we can open up the `Bandage` GUI.
```{bash eval=FALSE}
Bandage
```

Using this GUI we will open the `.gfa` files one at a time. Start with the `ecoli.1.dot.gfa` file (the 1st graph), then the `ecoli.2.dot.gfa` file (2nd), followed by the `ecoli.3.dot.gfa` file (3rd, last, and best).

To open a graph carry out the following

- On the tool bar click `File` -> `Load graph`
- In the pop up file explorer navigate to `~/bacterial_assembly/standard_workflow/redbean_assembly/` and double click on the `.gfa` file you would like to view.
- In the `Graph drawing` section on the right side bar:
   - Ensure `Scope:` is set to `Entire graph`
   - Ensure `Style` is set to `Single`
   - Click the `Draw graph` button

__Tips__: 

- The graph for `ecoli.1.dot.gfa` will take quite a while to load.
- The graphs for `ecoli.2.dot.gfa` and `ecoli.3.dot.gfa` are very large so you may need to change the `zoom` to 1%.

As you go from 1 to 3 you will see two many changes:

- __Fewer contigs__: This shows the assembler is connecting parts of the assembly to give a more contiguous assembly.
- __Fewer branches__: In the 1st and 2nd graphs you will see branches, parts of the graph that branch off and possibly reconnect again. This represents multiple paths through the assembly that are possible. Through the `Redbean` iterations the assembler chooses the best routes, removing the other routes. You will need to zoom in to properly see these branches.

## Other long read assemblers
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/canoe.png", auto_pdf = TRUE)
``` 

`Redbean` will not always be the optimal assembler. However, even if you plan to use another assembler `Redbean` is very good as a first pass tool due to its speed. It can be very useful to run a `Redbean` assembly and carry out genome assessment (shown in next chapter) to see if there are any issues with the reads that was not caught in the read QC. Various issues and solutions are covered in the supplemental bookdown.

Other long read assemblers to explore for yourself include (links in [appendix](#manuals)):

- `Canu`
- `HGAP`
- `Flye`
- `Raven`
- `NECAT`
- `Shasta`

<!--chapter:end:05-Assembly.Rmd-->

# Genome assembly assessment {#genomeassemblyassessment}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/inspect.png", auto_pdf = TRUE)
```



## Assessment: Conda environnment & directory
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/conda.png", auto_pdf = TRUE)
``` 

We will use the `bacterial_genome_assessment` `conda` environment for our `Redbean` assembly.

```{bash eval=FALSE}
chos 8
. usebacterialassembly
```

```{bash eval=FALSE}
cd ~/bacterial_assembly/standard_workflow
```

## QUAST

```{bash eval=FALSE}
mkdir -p quast/redbean
quast -o quast/redbean redbean_assembly/ecoli.ctg.fa
```

```{bash eval=FALSE}
firefox quast/redbean/report.html
```

## BUSCO

```{bash eval=FALSE}
mkdir -p busco/redbean
cd busco/redbean
```

```{bash eval=FALSE}
busco --list-datasets | less -S
```

```{bash eval=FALSE}
busco -i ../../redbean_assembly/ecoli.ctg.fa -l enterobacterales_odb10 -m geno -o ecoli
```

```{bash eval=FALSE}
less ecoli/short_summary.specific.enterobacterales_obd10.ecoli.txt
```

## CheckM

```{bash eval=FALSE}
cd ~/bacterial_assembly/standard_workflow
mkdir -p checkm/redbean/ecoli
```

```{bash eval=FALSE}
checkm lineage_wf --tab_table -f checkm/ecoli_checkm.tsv -t 8 -x ctg.fa redbean_assembly/ checkm/redbean/ecoli
```

```{bash eval=FALSE}
less -S checkm/redbean/ecoli/ecoli_checkm.tsv
```

<!--chapter:end:06-Genome_assessment.Rmd-->

# Polishing {#polishing}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/polishing.png", auto_pdf = TRUE)
``` 


## Racon


### Racon: Conda environment & directory
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/conda.png", auto_pdf = TRUE)
``` 

We will use the `bacterial_assembly` conda environment for our Redbean assembly.

```{bash eval=FALSE}
. usebacterialassembly
```

```{bash eval=FALSE}
cd ~/bacterial_assembly/standard_workflow
mkdir -p racon/redbean/ecoli
```

### Racon: Index assembly
```{bash eval=FALSE}
bwa index redbean_assembly/ecoli.ctg.fa
```

### Racon: Read alignment to assembly
```{bash eval=FALSE}
bwa mem \
-t 8 \
-x pacbio redbean_assembly/ecoli.ctg.fa \
ecoli_reads/ecoli.fastq \
> racon/redbean/ecoli/ecoli_i1.sam
```

### Racon: Polishing
```{bash eval=FALSE}
racon -t 8 \
ecoli_reads/ecoli.fastq \
racon/redbean/ecoli/ecoli_i1.sam redbean_assembly/ecoli.ctg.fa \
> racon/redbean/ecoli/ecoli_i1.fasta
```

### Racon: Polishing report

We can compare the redbean assembly and the polished assmebly to get a polishing report. This can be carried out with the `dnadiff` command from the program `mummer`.

```{bash eval=FALSE}
mkdir racon/redbean/ecoli/dnadiff
```

```{bash eval=FALSE}
dnadiff --prefix racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi1 redbean_assembly/ecoli.ctg.fa racon/redbean/ecoli/ecoli_i1.fasta
```

```{bash eval=FALSE}
less -S racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi1.report
```

(total seqs went from 4 to 1, total bases decreased by ~50k, 627 SNPs i.e. base changes)

`dnadiff` README:
https://github.com/mummer4/mummer/blob/master/docs/dnadiff.README


### Racon: Second iteration

With genome polishing normally multiple iterations of polishing are required. Therefore let us polish the polished assembly to create the second iteration of polishing.

```{bash eval=FALSE}
bwa index racon/redbean/ecoli/ecoli_i1.fasta

bwa mem -t 8 -x pacbi racon/redbean/ecoli/ecoli_1.fasta ecoli_reads/ecoli.fastq > racon/redbean/ecoli/ecoli_i2.sam

racon -t 8 ecoli_reads/ecoli.fastq racon/redbean/ecoli/ecoli_i2.sam racon/redbean/ecoli/ecoli_1.fasta > racon/redbean/ecoli/ecoli_i2.fasta
```

```{bash eval=FALSE}
dnadiff --prefix racon/redbean/ecoli/dnadiff/ref_raconi1_query_raconi2 racon/redbean/ecoli/ecoli_i1.fasta racon/redbean/ecoli/ecoli_i2.fasta
```

```{bash eval=FALSE}
less -S racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi2.report
```

(40 SNPs, much reduced, looking for convergence, eventually number of changes will stabilise showing bases that could be one or the other)

<!--chapter:end:07-Polishing.Rmd-->

# Circlator {#Circlator}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/circlator.png", auto_pdf = TRUE)
``` 


```{bash eval=FALSE}
chos 8
. usecirclator
```


```{bash eval=FALSE}
canu -correct -p ecoli -d ecoli_reads genomeSize=4.6m -pacbio ecoli_reads/ecoli.fastq
```

#don’t actually run as will take ~30 minutes

#instead copy predoen
```{bash eval=FALSE}
cp /pub39/tea/matthew/NEOF/bact_assembly/data/ecoli.correctedReads.fasta.gz ecoli_reads
gunzip ecoli_reads/ecoli.correctedReads.fasta.gz
```


#circlator 
```{bash eval=FALSE}
mkdir -p circlator/redbean_racon_i2/
```
```{bash eval=FALSE}
circlator all racon/redbean/ecoli/ecoli_i2.fasta ecoli_reads/ecoli.correctedReads.fasta circlator/redbean_racon_i2/ecoli
```


(note always good to assess after these type of steps but we will contiue with annotation followed by assessment)

<!--chapter:end:08-Circlator.Rmd-->

# Annotation {#annotation}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/quokka.png", auto_pdf = TRUE)
``` 

```{bash eval=FALSE}
chos 8
. useprokka
```

```{bash eval=FALSE}
cd ~/cd bacterial_assembly/standard_workflow
mkdir final_assembly
cd final_assembly
```


```{bash eval=FALSE}
mkdir assembly
cp ../circlator/redbean_racon_i2/ecoli/06.fixstart.fasta assembly/ecoli.fasta
```

```{bash eval=FALSE}
mkdir prokka
```


```{bash eval=FALSE}
#outdir must not exist
prokka --addgenes --prefix ecoli --outdir prokka/ecoli assembly/ecoli.fasta
```

#look at summary output

```{bash eval=FALSE}
less -S prokka/ecoli/ecoli.txt
```

<!--chapter:end:09-Annotation.Rmd-->

# Final report {#finalreport}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/quokka.png", auto_pdf = TRUE)
``` 

## Report

### Report: Conda environment & directory
```{r, fig.align = 'center',out.width= '10%', echo=FALSE }
knitr::include_graphics(path = "figures/conda.png", auto_pdf = TRUE)
``` 

```{bash eval=FALSE}
chos 8
. usebacterialgenomeassessment
```

```{bash eval=FALSE}
cd ~/bacterial_assembly/standard_workflow/final_assembly
```

### Report: QUAST

```{bash eval=FALSE}
cp -r /pub39/tea/nsc006/NEOF/bact_assembly/ref/ ~/bacterial_assembly/
```

(use reference)
```{bash eval=FALSE}
mkdir quast
quast -r ../../ ecoli_ref.fasta -o quast assembly/ecoli.fasta
```

### Report: BUSCO

```{bash eval=FALSE}
mkdir busco
busco -i assembly/ecoli.fasta -l enterobacterales_odb10 -m geno -o ecoli --out_path ./busco/
```

### Report: MultiQC

(change commands)
```{bash eval=FALSE}
mkdir multiqc
cd multiqc
mkdir input
cp ../quast/report.tsv input/
cp ../busco/ecoli/short_summary.specific.enterobacterales_odb10.txt input/
cp ../prokka/ecoli/ecoli.txt input/
```

```{bash eval=FALSE}
multiqc --cl-config "prokka_fn_snames: True" -o . input/*
```

```{bash eval=FALSE}
firefox multiqc_report.html
```


MultiQC modules: https://multiqc.info/docs/#multiqc-modules

<!--chapter:end:10-Final_report.Rmd-->

# Cleanup {#cleanup}
```{r, fig.align = 'center',out.width= '20%', echo=FALSE }
knitr::include_graphics(path = "figures/quokka.png", auto_pdf = TRUE)
``` 

Like to remove intermediary files that are not needed. We could delete all the directories apart from final assembly however we will delete files that are definitely not needed, leaving files that we may want to use again (assembly fasta files, stats etc.).

You can delete files you definitely don't need as you go along (recommended for large files or if storage space is a premium) but I tend to do my cleanup at the end of a project.

cd ~/bacterial_assembly_standard_workflow

du -hsc *

##redbean

du -hsc redbean_assembly/*

#delete the gzipped files that we will most likely never even look at
#always like to ls when using wildcards or deleting directories before deleting to make sure your are not deleting anything you don’t want to
ls redbean_assembly/*gz
rm redbean_assembly/*gz

#delete the index files for the assembly we created for racon polishing
ls redbean_assembly/ecoli.ctg.fa.*
rm redbean_assembly/ecoli.ctg.fa.*

## quast

Generally quast does not produce large files so we will ignore it here

## busco

du -hsc busco/redbean/*

rm -r busco/redbean/busco_downloads

ls busco/redbean/busco_*.log
rm busco/redbean/busco_*.log

du -hsc busco/redbean/ecoli/*
ls busco/redbean/ecoli/logs
rm -r busco/redbean/ecoli/logs
ls busco/redbean/ecoli/prodigal_output
rm -r busco/redbean/ecoli/prodigal_output
#The below directory may be useful but normally the short summary is sufficient to keep and use
ls busco/redbean/ecoli/run_enterobacterales_odb10
rm -r busco/redbean/ecoli/run_enterobacterales_odb10

## checkm

du -hsc checkm/redbean/ecoli/*

ls checkm/redbean/ecoli/storage
rm -r checkm/redbean/ecoli/storage

## racon

du -hsc racon/redbean/ecoli/*

#delete sam files, these are relatively large
ls racon/redbean/ecoli/*sam
rm racon/redbean/ecoli/*sam

#index files
ls racon/redbean/ecoli/*.fasta.*
rm racon/redbean/ecoli/*.fasta.*

#dnadiff has small files so we will leave alone
du -hsc racon/redbean/ecoli/dnadiff*

##circlator
du -hsc circlator/redbean_raconi2/ecoli/*

#we can delete all the 00-05 files

ls circlator/redbean_raconi2/ecoli/0[0-5]*
rm circlator/redbean_raconi2/ecoli/0[0-5]*

## All prokkas files are useful

##I will let you cleanup in the final assembly directory

## tar
#Good to tar a directory when not needed any more
#Lots of files will slow a cluster a tarred directory will only count as one file

#do with a practice directory we’ll make by copying our standard_workflow_directory
cd ~/bacterial_assembly
cp -r standard_workflow standard_workflor_backup

tar -czvf standard_workflow.tar.gz standard_workflor_backup
#you can watch as the different files are compressed

rm -rf standard_workflow_backup

#UNtar
tar -xzvf standard_workflow.tar.gz
ls standard_workflow_backup

<!--chapter:end:11-Cleanup.Rmd-->

# (APPENDIX) Appendix {-}

# Next steps{#nextsteps}
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/step.png", auto_pdf = TRUE)
``` 

- `Conda` and `Mamba` are invaluable tools to install programs and create virtual environments.
- Benchmarks of long-read assemblers paper.
   - https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6966772/




# Manuals{#manuals}
```{r, fig.align = 'center',out.width= '15%', echo=FALSE }
knitr::include_graphics(path = "figures/manual.png", auto_pdf = TRUE)
``` 

Conda: https://conda.io/projects/conda/en/latest/user-guide/getting-started.html

Mamba: https://github.com/mamba-org/mamba

Redbean (wtdbg2): https://github.com/ruanjue/wtdbg2

Bandage: https://rrwick.github.io/Bandage/

GFA spec: http://gfa-spec.github.io/GFA-spec/GFA1.html

Canu: https://github.com/marbl/canu

HGAP: https://github.com/PacificBiosciences/Bioinformatics-Training/wiki/HGAP

Flye: https://github.com/fenderglass/Flye

Raven: https://github.com/lbcb-sci/raven

NECAT: https://github.com/xiaochuanle/NECAT

Shasta: https://github.com/chanzuckerberg/shasta



FastQC: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/

MultiQC: https://multiqc.info/

Trim Galore: https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/

Bowtie2: http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml

samtools: http://www.htslib.org/

BBTools: https://jgi.doe.gov/data-and-tools/bbtools/

Kraken2: https://github.com/DerrickWood/kraken2/wiki/Manual

Krona: https://github.com/marbl/Krona/wiki/KronaTools

Bracken: https://ccb.jhu.edu/software/bracken/index.shtml?t=manual

LEfSe: https://huttenhower.sph.harvard.edu/lefse/

HUMAnN2: https://github.com/biobakery/biobakery/wiki/humann2

MetaPhlAn2: https://huttenhower.sph.harvard.edu/metaphlan2/

Biobakery: https://github.com/biobakery/biobakery

MegaHit: https://github.com/voutcn/megahit

BWA: https://github.com/lh3/bwa

minimap2: https://github.com/lh3/minimap2

MetaBAT2: https://bitbucket.org/berkeleylab/metabat/src/master/

CheckM: https://github.com/Ecogenomics/CheckM/wiki

PhyloPhlAn: https://github.com/biobakery/phylophlan/wiki

MetaWRAP: https://github.com/bxlab/metaWRAP

Pokka: https://github.com/tseemann/prokka

MinPath: https://github.com/mgtools/MinPath/blob/master/readme

MetaCyc: https://metacyc.org/

# Obtaining Read Data

https://github.com/PacificBiosciences/DevNet/wiki/8-plex-Ecoli-Multiplexed-Microbial-Assembly


<!--chapter:end:12-Appendix.Rmd-->

