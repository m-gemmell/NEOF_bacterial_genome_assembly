[["01-Bacterial_genome_supplemental.html", "Bacterial genome assembly and annotation supplemental Chapter 1 Supplemental", " Bacterial genome assembly and annotation supplemental Matthew R. Gemmell 2021-08-12 Chapter 1 Supplemental Commands are in the following font, colour, and box.They should be run in the command line. echo &quot;This is a command example&quot; "],["02-Multi-sample_workflow.html", "Chapter 2 Multiple sample workflow 2.1 Multiple sample raw data 2.2 Sample file 2.3 Start looping 2.4 Continuing the workflow", " Chapter 2 Multiple sample workflow In the standard workflow bookdown we assembled and annotated a single sample/genome. In your future projects you will most likely need to carry this out for multiple samples at one. This could be carried out by running each command for each sample separately. However, there are much quicker methods. In this section I will introduce you to my preferred method of carrying out commands on multiple samples. This involves a text file containing all the samples names in conjunction with while read loops. 2.1 Multiple sample raw data Prior to running we need the data first. Copy over the directory that contains the data and will be used as the analysis directory. #Move to your bacterial_assembly directory cd ~/bacterial_assembly/ #Create a multi_sample_workflow directory with a data subdirectory mkdir -p multi_sample_workflow/data #Move into the new analysis directory cd multi_sample_workflow We will be running three Bacillus cereus samples through the standard workflow. Well create softlinks of the PacBio fastq files (always good if you know the sequencing data will not be moved or deleted). #Softlink the PacBio fastq files we will use ln -s /pub39/tea/nsc006/NEOF/bact_assembly/multi_sample_workflow/* data/ #List contents of the data directory ls data 2.2 Sample file Now it is time to make the sample file we will use for the future while read loops. This file will contain the sample names, one sample name per line. For ease and convenience we will change the prefix of our PacBio fastq files to that of our desired samples names. In this case it is simply removing the _0001.fastq part. We could simply rename all the files with the mv command but this might be awkward with many files. Instead we will use the rename command #Move into the data directory cd data #Rename the files rename &quot;s/_0001//&quot; *.fastq #List contents ls . rename will rename all indicated files (*.fastq: all files in current directory with the suffix .fastq) using syntax similar to the sed command. The \"s/_0001//\" is made of four parts: s/: The s indicates we are carrying out a substitution. /_0001/: The first instance of _0001 is to be substituted. //: The matched pattern (_0001) is to be substituted with nothing. For more info on sed please the Intro to Unix bookdown. With our newly named softlinks we can quickly create our sample file. #List fastq files ls *fastq #List fastq files and remove the suffix (i.e. list sample names) ls *fastq | sed &quot;s/.fastq//&quot; #Redirect sample names to a new sample file ls *fastq | sed &quot;s/.fastq//&quot; &gt; ../samples.txt Move up one directory to the main analysis directory and view the contents of the sample file. #Move up one directory cd .. #Print samples.txt contents to screen cat samples.txt 2.3 Start looping Now that we have our data and our sample file we can start carrying out the standard workflow with loops. First ensure you are in a terminal with an activate bacterial_assembly environment then create an assembly output directory. mkdir redbean_assembly Now to run the redbean assembly steps with loops #wtdbg2 step cat samples.txt | while read s do wtdbg2 \\ -x rs \\ -g 5.4m \\ -i data/${s}.fastq \\ -o redbean_assembly/${s} \\ -t 8 done #Derive consensus cat samples.txt | while read s do wtpoa-cns \\ -t 8 \\ -i redbean_assembly/${s}.ctg.lay.gz \\ -fo redbean_assembly/${s}.ctg.fa done As can be seen the contents of the file samples.txt is provided to the loop (while read) with a cat command and a pipe |. When looping through this file the commands in the loop are carried out three times, once for each samples. In future cases the loop will occur as many times as there are lines in the samples.txt file. In each loop the ${s} is replaced with the current line from the file. s is set as the variable by the user when the loop is initiated (while read s). s is arbitrary and I use it to be short for sample. It could be any letter or even a word. Below we will put the wtdbg2 within an echo within the loop. This will print out to screen the commands that would be run, replacing the variables (${s}) with the sample names. This is useful to get a sense of what the loop is actually doing. This can also be a handy way to debug your loops if they are not working as intended. cat samples.txt | while read s do echo `wtdbg2 \\ -x rs \\ -g 5.4m \\ -i data/${s}.fastq \\ -o redbean_assembly/${s} \\ -t 8` done Note: Loops need to start with do and end with done as shown in the command. 2.4 Continuing the workflow With this quick intro to using while loops and the Standard workflow bookdown complete genome assembly and annotation for these three samples. Finish off with one final MultiQC report containing the final QUAST , BUSCO, and Prokka info for all the samples. Notes: QUAST: This command can be provided multiple assembly files at once so loop wont be needed. BUSCO: Ensure you use the correct lineage dataset. MultiQC: Like QUAST no loop is required for this command. "],["03-High_coverage.html", "Chapter 3 High coverage 3.1 Detecting high coverage 3.2 Subsampling", " Chapter 3 High coverage Low sequence coverage (&lt;20X) can cause assembly issues due to: Under represented areas of the genomes. Sequencing will not lead to uniform coverage across the genome and so the lower coverage areas may not be missing of have very low coverage. Errors cannot be corrected/polished. Low coverage may mean there are areas which do not have enough sequences to produce an accurate assembly. Low sequence coverage can be corrected by carrying out more sequencing. High sequence coverage (&gt;100X) may seem perfect but it can cause issues. Although it may seem good, high coverage will cause assembly issues. As coverage increases the number of errors in the data increases (even if the % of errors is stable). If data contains a 10% error rate then 100 megabases will contain 10 megabases of errors whilst 1 gigabase will contain 100 megabases of errors. It is a lot easier for an assembly to detemrine what may be errors if there is a smaller total amount of them. The errors will confuse the assembler and it may create create an assembly graph that looks like a bowl of spaghetti rather than one long spaghetti strand. If you provide enough coverage the assembler may never finish or crash due to memory limitations as it tries to disentangle the graph. How do we prevent this? 3.1 Detecting high coverage To detect high coverage (&gt;100X) you will need to first know the estimate size of your genome. Then you can look at the sequencing summary to hopefully find the number of bases in your sequencing data. If you do not have this we can use some quick unix command sto do this. #Move into the directory with your ecoli reads cd ~/bacterial_assembly/standard_workflow/ecoli_reads #Print out to screen the number of bases in ecoli.fastq cat ecoli.fastq | paste - - - - | cut -f 2 | wc -c The command consists of multiple parts with the parts piping (|) their outputs to be the next commands input. The parts are: cat ecoli.fastq : read ecoli.fastq to use it as the intial input for the commands. paste - - - - : This separates the lines into columns. Four columns are specified here by - - - -. As each fastq entry consists of four lines this works perfectly to create a header, a sequence, a quality header, and a quality column. cut -f 2 : cut will extract our field/column (-f) of choice. In this case it is the 2nd field as all the sequence data is in the second field. Therefore we have removed all non sequence information. wc -c : wc stands for word count and the -c options stands for characters. We are therefore counting all the characters. We therefore print to screen the number of bases in the fastq file. With this we can find out if we may have too much coverage. In this case 106,770,005bp is about 23X for a 4.6m genome (E.coli) so we are definitely not worried about the coverage being too high. 3.2 Subsampling To reduce the coverage we can subsample the reads. This is the act of randomly extracting reads (without replacement) to a set number or fraction. As the process is random it should not add in any bias (or at least any more bias than is present in sequencing anyway). We will use Seqtk along with its option subsample to extract half (0.5) of the ecoli reads in the hopes we will be left with slightly more than 50Mbp. Note: Use the Conda environment bacterial_assembly. seqtk sample -s 100 ecoli.fastq 0.5 &gt; ecoli_subsample.fastq Parameters -s 100 : This indicates the random seed to be used for subsampling. This can be any number and is arbitrarily chosen. With Paired reads this number must be the same for the forward and reverse reads. This is to ensure the two files have matching reads. ecoli.fastq : The first flagless parameter to indicate the input fastq file. 0.5 : The second flagless parameter to indicate the subsample size. If the number is a fraction (0.5, 0.2, 0.87 etc.) then the specified fraction of reads (compared to the intial total) will be extracted. if the number is a whole number (1, 100, 98762 etc.) the specified number of reads will be extracted. As we extract by number/fraction of reads and the size of PacBio and ONT reads vary we may not get the number of bases we desire. It is therefore always good to count the number of bases in our subsamples file. cat ecoli_subsample.fastq | paste - - - - | cut -f 2 | wc -c Tasks Using seqtk sample attempt to subsample the data so you retain ~10X coverage (44-48Mbp). What fraction/number did you use? Try out different seed numbers, with the same subsample number/fraction, to see the effect it has on subsampling. Note There is probable no reason you would want 10X in real life this is just for practice. I generally suggest only carrying out random subsampling if you have very high coverage (&gt;100X) and trying to get subsample to get a coverage close to 100X (95-100X). It does not have to be very exact as even a coverage of 80X would be very good for a bacterial genome. "],["04-Hybrid_assembly.html", "Chapter 4 Hybrid assembly 4.1 Hybrid assembly: Conda environment &amp; directory 4.2 hybridSPAdes", " Chapter 4 Hybrid assembly Hybrid assembly methods can be used when you have long read (PacBio or ONT) and short read (Illumina) sequencing data for your samples. There are two main methods for this. Use both during the assembly step (hybridSPAdes) Assemble with the long reads and polish with the short reads (pilon) 4.1 Hybrid assembly: Conda environment &amp; directory We will use the bacterial_assembly conda environment for our Racon polishing. Either: Use your currently open bacterial_assembly terminal. If you need a new bacterial_assembly terminal see the bacterial assembly conda activation instructions Before running any commands we will get directories and data setup. 4.2 hybridSPAdes A popular hybrid assembler for bacterial genomes is hybridSPAdes. In this case it is used the same as for just using Illumina data but with the addition of the --pacbio for PacBio reads or --nanopore for Oxford nanopore reads. "],["12-Appendix.html", "A Next steps B Manuals C Obtaining Read Data", " A Next steps Conda and Mamba are invaluable tools to install programs and create virtual environments. Assembly algorithms for next-generation sequencing data https://www.sciencedirect.com/science/article/pii/S0888754310000492 The Most Frequently Used Sequencing Technologies and Assembly Methods in Different Time Segments of the Bacterial Surveillance and RefSeq Genome Databases. https://www.frontiersin.org/articles/10.3389/fcimb.2020.527102/full Benchmarks of long-read assemblers paper. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6966772/ Predicting metabolic pathways using MinPath https://metagenomics-workshop.readthedocs.io/en/2014-11-uppsala/functional-annotation/minpath.html B Manuals Conda: https://conda.io/projects/conda/en/latest/user-guide/getting-started.html Mamba: https://github.com/mamba-org/mamba Redbean (wtdbg2): https://github.com/ruanjue/wtdbg2 Bandage: https://rrwick.github.io/Bandage/ GFA spec: http://gfa-spec.github.io/GFA-spec/GFA1.html Canu: https://github.com/marbl/canu HGAP: https://github.com/PacificBiosciences/Bioinformatics-Training/wiki/HGAP Flye: https://github.com/fenderglass/Flye Raven: https://github.com/lbcb-sci/raven NECAT: https://github.com/xiaochuanle/NECAT Shasta: https://github.com/chanzuckerberg/shasta QUAST: http://quast.sourceforge.net/quast BUSCO: https://busco.ezlab.org/ CheckM: https://github.com/Ecogenomics/CheckM/wiki BWA: https://github.com/lh3/bwa SAM: https://samtools.github.io/hts-specs/SAMv1.pdf RACON: https://github.com/isovic/racon MUMmer: http://mummer.sourceforge.net/ dnadiff: https://github.com/mummer4/mummer/blob/master/docs/dnadiff.README Pilon: https://github.com/broadinstitute/pilon/wiki PacBios GenomicConsensus: https://github.com/broadinstitute/pilon/wiki HyPo: https://github.com/kensung-lab/hypo Medaka: https://github.com/nanoporetech/medaka NextPolish: https://github.com/Nextomics/NextPolish Canu: https://github.com/marbl/canu Circlator: https://github.com/sanger-pathogens/circlator Prokka: https://github.com/tseemann/prokka EC numers: https://en.wikipedia.org/wiki/Enzyme_Commission_number COG: https://www.ncbi.nlm.nih.gov/research/cog IGV: https://software.broadinstitute.org/software/igv/v1.2 Artemis: http://sanger-pathogens.github.io/Artemis/Artemis/ GhostKOALA: https://www.kegg.jp/ghostkoala/ MinPath: https://github.com/mgtools/MinPath C Obtaining Read Data https://github.com/PacificBiosciences/DevNet/wiki/8-plex-Ecoli-Multiplexed-Microbial-Assembly "]]
