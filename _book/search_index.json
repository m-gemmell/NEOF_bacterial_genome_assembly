[["01-Bacterial_genome_assembly_and_annotation.html", "Bacterial genome assembly and annotation Chapter 1 Introduction", " Bacterial genome assembly and annotation Matthew R. Gemmell 2021-08-03 Chapter 1 Introduction This practical session will run you through a standard bacterial genome assembly and annotation workflow using PacBio data. The topics covered are: Setup Overview Genome assembly with Redbean (wtdbg2) Assembly assessment Polishing with arrow Circularisation with Circlator Annotation with Prokka Final report generation with MultiQC The aim of this practical is to produce a genome assembly of Eschrichia coli, annotate it, and produce a report with the assemblys stats. Read QC will be skipped as this has been covered in a previous NEOF workshop. Commands are in the following font, colour, and box.They should be run in the command line. echo &quot;This is a command example&quot; "],["02-Cluster_Introduction.html", "Chapter 2 Cluster Introduction 2.1 Logon instructions 2.2 The Terminal Window", " Chapter 2 Cluster Introduction 2.1 Logon instructions For this workshop we will be using Virtual Network Computing (VNC). Connect to the VNC with a browser by using the webVNC link you were sent. You will now be in a logged-in Linux VNC desktop. You will see something as below (there may be only one terminal which is fine). If you do not see something similar please ask for assistance. If the VNC is taking up too much/little space of your browser you can use the zoom of your browser to adjust the size. Ensure you can see one whole terminal. These instructions will not work outside of this workshop. If you would like to install your own Linux OS on your desktop or laptop we would recommend Ubuntu. The following link is a guide to install Ubuntu: https://www.ubuntu.com/download/desktop/install-ubuntu-desktop. If you use a USB you need to create a bootable USB stick. The following link will assist: https://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows 2.2 The Terminal Window In our case the terminal window looks like the picture below. We are using the terminal window as our shell to interpret our commands to the kernel. Depending on your system and preferences it may look different. Already there is useful information for us on the terminal window. nsc065: This is the login name, also known as the username. In this case nsc065 is a demonstrators account. Your screen should show a different account name which will be your username for the Linux machine/cluster you are logged into. gauss03: This is the machine name the user is logged into. ~: This represents the current directory of the user, or the directory a command was run in. In the Linux OS and others ~ is a shortcut to the users home directory. Everything after the $ is where commands are typed into the terminal. This is also referred to as the command line. To open a new terminal window, right click on the main screen, choose Applications -&gt; Shell -&gt; bash "],["03-Start.html", "Chapter 3 Setup 3.1 Workshop directory &amp; data 3.2 Conda environments", " Chapter 3 Setup 3.1 Workshop directory &amp; data Prior to starting analysis we will create a working directory. The directory ~/bacterial_assembly/standard_workflow will contain all the inputs and outputs of our analyses. #Make directory mkdir -p ~/bacterial_assembly/standard_workflow #Move into it cd ~/bacterial_assembly/standard_workflow During the workflow we will keep a tidy directory structure outputting the results form different tools into their respective directories. For the standard workflow we will be using pre QCd PacBio reads of an Escherichia coli genome. Create a directory and create soft links (i.e. a shortcut) of the read data. #Create directory mkdir ecoli_reads #Softlink of read data ln -s /pub39/tea/nsc006/NEOF/bact_assembly/data/ecoli.fastq ecoli_reads 3.2 Conda environments Conda is a very useful tool for bioinformaticians. It allows for the creation of virtual environments so you can install different programs. This is generally easier than manually installing programs for 2 main reasons: Normally Conda will install all the dependencies a program needs. Prior to Conda it could take more than a day to install a program and all its dependencies plus the dependencies of the dependencies etc. Different programs may need different versions of the same program as a dependency (e.g. One program may need Python2 whilst another needs Python3). Therefore installing one can break the other. Having separate Conda environments (virtual environments) can isolate clashing programs. Analogy: You can think of programs as food and environments as food storage units. You could try to shove all your food into one giant cold room but most of your food will either be too cold or too warm. Instead it would be better to have different types of food in different environments as outlined in the below table. Storage environment Food examples Fridge Fresh vegetables, fresh meat, etc. Freezer Frozen meat, ice, etc. Pantry Canned food, jarred food, etc. Cellar Wine. Fruit bowl Fruit. As we will be using many different programs we will be using different Conda environments. To activate these environments you will be using use scripts that will activate the relevant Conda environment belonging to user nsc006 (Matthew Gemmell). Preferably during the course of this workflow you will have a terminal open for each Conda environment. It is important to make sure you are in the correct terminal/environment for each chapter. You can see what environment a terminal currently has activated by looking at the command prompt. In the below picture we can see the command prompt says we are in the environment called bacterial_assembly. The name of the currently activated Conda environment will always be in () before the login/user name across all systems when using Conda. For your own future analyses you would use your own Conda. If you are interested please see the Conda and Mamba links in the Next steps section of the Appendix. "],["04-Overview.html", "Chapter 4 Overview 4.1 Overview: Bacterial genome assembly 4.2 Overview: Long read data 4.3 Overview: Read QC 4.4 Overview: Assembly 4.5 Overview: Assembly assessment 4.6 Overview: Polishing 4.7 Overview: Circlator 4.8 Overview: Annotation 4.9 Overview: Final report", " Chapter 4 Overview 4.1 Overview: Bacterial genome assembly (Specific points about bacterial genome assembly) 4.2 Overview: Long read data (short versus long read assembly. long read becoming more popular) (PacBio vs ONT, this standard pipeline will work for ONT with some changes) 4.3 Overview: Read QC (talk about the read data here and how it was created) 4.4 Overview: Assembly 4.5 Overview: Assembly assessment 4.6 Overview: Polishing 4.7 Overview: Circlator 4.8 Overview: Annotation 4.9 Overview: Final report "],["05-Assembly.html", "Chapter 5 Genome Assembly 5.1 Redbean 5.2 Bandage Visualisation 5.3 Other long read assemblers", " Chapter 5 Genome Assembly The first step of any genome assembly project is to carry out is QC of the read data. The very next step is genome assembly. There are many different assemblers and in the past the choice of assembler and its parameters was the primary task to produce a good quality assembly after getting good quality reads. The bioinformaticians choice of assembler and parameters is not as vital as it once was. This is due to great improvements to sequencing technologies and bioinformatics processes which include: Sequencing technologies are creating longer and higher quality reads. The better the length and quality, the less work assemblers needs to do. There may come a time when you can get one read that perfectly represents an entire genome/chromosome. Assembly would not be required at all. Genome assemblers are improving. There is a large choice of good genome assemblers. It is less a question of which to use and more a question of which not to use. Genome assembly parameter choice is a smaller issue. For older assemblers and older versions of assemblers it would take a lot of trial and error to try to find the best parameters. Now like many bioinformatics tools, assemblers will attempt to use the best parameters for your data. Generally they are better and quicker than humans at this. 5.1 Redbean For assembly of our PacBio reads we will be using Redbean (AKA wtdbg2). Redbean is a long read assembler with comparable performance to others. However, where it excels is its speed, it is much faster than other long read assemblers. This make it perfect for this workshop. Redbean can be used for genomes of all sizes. It will work for Viruses, Bacteria, Archaea, and Eukaryotes. Redbean works for PacBio RSII, PacBio Sequel, and Oxford nanopore data. 5.1.1 Redbean: Conda environment &amp; directory We will use the bacterial_assembly conda environment for our Redbean assembly. This will be our main conda environment for our standard workflow. Activate the environment: . usebacterialassembly Before we start we will move into our analysis directory (created in setup) and create a directory for the assembly we will produce. #Change directory to analysis directory cd ~/bacterial_assembly/standard_workflow #Create directory for redbean output mkdir redbean_assembly 5.1.2 Redbean: Assemble long reads The first step of Redbean is to carry out the assembly. This is carried out with the wtdgb2 command. wtdbg2 -x rs -g 4.6m -i ecoli_reads/ecoli.fastq -o redbean_assembly/ecoli -t 8 Parameters -x : This indicates the sequencing technology of the input reads. rs = PacBio RSII sq = PacBio Sequel ccs = PacBio CCS reads ont = Oxford Nanopore -g : This indicates the estimated size of the genome This does not need to be super exact with and you ca round up to two significant figures. Examples are below. E.coli | genome size = 4,639,221 bp =&gt; -g 4.6m (m = megabases) Phi-X174 | genome size = 5386 bp =&gt; -g 5.4k (k = kilobase) H.Sapiens | genome size = 3.2Gb =&gt; -g 3g (g = gigabase) -i : The input reads. -o : The output prefix. With this set to redbean_assembly/ecoli all the output files will be in the directory redbean_assembly with the prefix ecoli. -t : Number of threads to be used. The will create a bunch of output files. Most of these we will ignore with only 4 being used below. 5.1.3 Redbean: Derive consensus If you checked the output directory you may have noticed there was no fasta file. Therefore the next step is to create a fasta file that contains the consensus assembly with wtpoa-cns. wtpoa-cns -t 8 -i redbean_assembly/ecoli.ctg.lay.gz -fo redbean_assembly/ecoli.ctg.fa Parameters -i : The input ctg.lay.gz file produced by wtdbg2 -fo : The output file path for the consensus assembly in fasta format. -t : Number of threads to be used. The consensus is produced from the assembly graph (more on the graph below). Assembly is not always straight forward and when producing a graph, an assembler may derive multiple paths/branches through the assembly. Two examples of how this may occur are: Repeating regions: An assembler may find it hard to determine how many times a repeat occurs within the repeat region. Maybe it is 10 or 11 times. Identical homopolymers: It is possible that long homopolymers of As (or one of the other bases) occurs multiple times in the genome. It may then be difficult to know what is at either end of each unique homopolymer location. E.g. There are 2 homopolymer sequences (H1 &amp; H2) with 4 ends (E1-4). Is H1 flanked by E1 and E2 and therefore H2 is flanked by E3 and E4? Or is H1 flanked by E1 and E3 and therefore H2 is flanked by E2 and E4? Etc. The consensus can then be thought of as the one best path through the graph to produce the most likely genome assembly. 5.2 Bandage Visualisation This part is optional and generally something I never do in real analyses. However, it is interesting and will help your understanding of assembly graphs. Redbean carries out 3 iterations of graph construction, each getting better. These three graph iterations are represented by the .dot.gz files. We can visualise these graphs with the tool Bandage. Before visualisation we need to convert the files to .gfa (link on file specs in appendix) files which are compatible with Bandage. First we need to gunzip the files. gunzip redbean_assembly/ecoli.1.dot.gz gunzip redbean_assembly/ecoli.2.dot.gz gunzip redbean_assembly/ecoli.3.dot.gz Next we convert the .dot files into .gfa files. The script wtdbg2-dot2gfa.pl is found in the scripts directory of wtdbg2 which can be found at: https://github.com/ruanjue/wtdbg2/tree/master/scripts. Unfortunately this is not installed when you install wtdbg2 via Conda. wtdbg-dot2gfa.pl redbean_assembly/ecoli.1.dot &gt; redbean_assembly/ecoli.1.dot.gfa wtdbg-dot2gfa.pl redbean_assembly/ecoli.2.dot &gt; redbean_assembly/ecoli.2.dot.gfa wtdbg-dot2gfa.pl redbean_assembly/ecoli.3.dot &gt; redbean_assembly/ecoli.3.dot.gfa Now we can open up the Bandage GUI. Bandage Using this GUI we will open the .gfa files one at a time. Start with the ecoli.1.dot.gfa file (the 1st graph), then the ecoli.2.dot.gfa file (2nd), followed by the ecoli.3.dot.gfa file (3rd, last, and best). To open a graph carry out the following On the tool bar click File -&gt; Load graph In the pop up file explorer navigate to ~/bacterial_assembly/standard_workflow/redbean_assembly/ and double click on the .gfa file you would like to view. In the Graph drawing section on the right side bar: Ensure Scope: is set to Entire graph Ensure Style is set to Single Click the Draw graph button Tips: The graph for ecoli.1.dot.gfa will take quite a while to load. The graphs for ecoli.2.dot.gfa and ecoli.3.dot.gfa are very large so you may need to change the zoom to 1%. As you go from 1 to 3 you will see two many changes: Fewer contigs: This shows the assembler is connecting parts of the assembly to give a more contiguous assembly. Fewer branches: In the 1st and 2nd graphs you will see branches, parts of the graph that branch off and possibly reconnect again. This represents multiple paths through the assembly that are possible. Through the Redbean iterations the assembler chooses the best routes, removing the other routes. You will need to zoom in to properly see these branches. 5.3 Other long read assemblers Redbean will not always be the optimal assembler. However, even if you plan to use another assembler Redbean is very good as a first pass tool due to its speed. It can be very useful to run a Redbean assembly and carry out genome assessment (shown in next chapter) to see if there are any issues with the reads that was not caught in the read QC. Various issues and solutions are covered in the supplemental bookdown. Other long read assemblers to explore for yourself include (links in appendix): Canu HGAP Flye Raven NECAT Shasta "],["06-Genome_assessment.html", "Chapter 6 Genome assembly assessment 6.1 Assessment: Conda environnment &amp; directory 6.2 QUAST 6.3 BUSCO 6.4 CheckM", " Chapter 6 Genome assembly assessment 6.1 Assessment: Conda environnment &amp; directory We will use the bacterial_genome_assessment conda environment for our Redbean assembly. chos 8 . usebacterialassembly cd ~/bacterial_assembly/standard_workflow 6.2 QUAST mkdir -p quast/redbean quast -o quast/redbean redbean_assembly/ecoli.ctg.fa firefox quast/redbean/report.html 6.3 BUSCO mkdir -p busco/redbean cd busco/redbean busco --list-datasets | less -S busco -i ../../redbean_assembly/ecoli.ctg.fa -l enterobacterales_odb10 -m geno -o ecoli less ecoli/short_summary.specific.enterobacterales_obd10.ecoli.txt 6.4 CheckM cd ~/bacterial_assembly/standard_workflow mkdir -p checkm/redbean/ecoli checkm lineage_wf --tab_table -f checkm/ecoli_checkm.tsv -t 8 -x ctg.fa redbean_assembly/ checkm/redbean/ecoli less -S checkm/redbean/ecoli/ecoli_checkm.tsv "],["07-Polishing.html", "Chapter 7 Polishing 7.1 Racon", " Chapter 7 Polishing 7.1 Racon 7.1.1 Racon: Conda environment &amp; directory We will use the bacterial_assembly conda environment for our Redbean assembly. . usebacterialassembly cd ~/bacterial_assembly/standard_workflow mkdir -p racon/redbean/ecoli 7.1.2 Racon: Index assembly bwa index redbean_assembly/ecoli.ctg.fa 7.1.3 Racon: Read alignment to assembly bwa mem \\ -t 8 \\ -x pacbio redbean_assembly/ecoli.ctg.fa \\ ecoli_reads/ecoli.fastq \\ &gt; racon/redbean/ecoli/ecoli_i1.sam 7.1.4 Racon: Polishing racon -t 8 \\ ecoli_reads/ecoli.fastq \\ racon/redbean/ecoli/ecoli_i1.sam redbean_assembly/ecoli.ctg.fa \\ &gt; racon/redbean/ecoli/ecoli_i1.fasta 7.1.5 Racon: Polishing report We can compare the redbean assembly and the polished assmebly to get a polishing report. This can be carried out with the dnadiff command from the program mummer. mkdir racon/redbean/ecoli/dnadiff dnadiff --prefix racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi1 redbean_assembly/ecoli.ctg.fa racon/redbean/ecoli/ecoli_i1.fasta less -S racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi1.report (total seqs went from 4 to 1, total bases decreased by ~50k, 627 SNPs i.e. base changes) dnadiff README: https://github.com/mummer4/mummer/blob/master/docs/dnadiff.README 7.1.6 Racon: Second iteration With genome polishing normally multiple iterations of polishing are required. Therefore let us polish the polished assembly to create the second iteration of polishing. bwa index racon/redbean/ecoli/ecoli_i1.fasta bwa mem -t 8 -x pacbi racon/redbean/ecoli/ecoli_1.fasta ecoli_reads/ecoli.fastq &gt; racon/redbean/ecoli/ecoli_i2.sam racon -t 8 ecoli_reads/ecoli.fastq racon/redbean/ecoli/ecoli_i2.sam racon/redbean/ecoli/ecoli_1.fasta &gt; racon/redbean/ecoli/ecoli_i2.fasta dnadiff --prefix racon/redbean/ecoli/dnadiff/ref_raconi1_query_raconi2 racon/redbean/ecoli/ecoli_i1.fasta racon/redbean/ecoli/ecoli_i2.fasta less -S racon/redbean/ecoli/dnadiff/ref_redbean_query_raconi2.report (40 SNPs, much reduced, looking for convergence, eventually number of changes will stabilise showing bases that could be one or the other) "],["08-Circlator.html", "Chapter 8 Circlator", " Chapter 8 Circlator chos 8 . usecirclator canu -correct -p ecoli -d ecoli_reads genomeSize=4.6m -pacbio ecoli_reads/ecoli.fastq #dont actually run as will take ~30 minutes #instead copy predoen cp /pub39/tea/matthew/NEOF/bact_assembly/data/ecoli.correctedReads.fasta.gz ecoli_reads gunzip ecoli_reads/ecoli.correctedReads.fasta.gz #circlator mkdir -p circlator/redbean_racon_i2/ circlator all racon/redbean/ecoli/ecoli_i2.fasta ecoli_reads/ecoli.correctedReads.fasta circlator/redbean_racon_i2/ecoli (note always good to assess after these type of steps but we will contiue with annotation followed by assessment) "],["09-Annotation.html", "Chapter 9 Annotation", " Chapter 9 Annotation chos 8 . useprokka cd ~/cd bacterial_assembly/standard_workflow mkdir final_assembly cd final_assembly mkdir assembly cp ../circlator/redbean_racon_i2/ecoli/06.fixstart.fasta assembly/ecoli.fasta mkdir prokka #outdir must not exist prokka --addgenes --prefix ecoli --outdir prokka/ecoli assembly/ecoli.fasta #look at summary output less -S prokka/ecoli/ecoli.txt "],["10-Final_report.html", "Chapter 10 Final report 10.1 Report", " Chapter 10 Final report 10.1 Report 10.1.1 Report: Conda environment &amp; directory chos 8 . usebacterialgenomeassessment cd ~/bacterial_assembly/standard_workflow/final_assembly 10.1.2 Report: QUAST cp -r /pub39/tea/nsc006/NEOF/bact_assembly/ref/ ~/bacterial_assembly/ (use reference) mkdir quast quast -r ../../ ecoli_ref.fasta -o quast assembly/ecoli.fasta 10.1.3 Report: BUSCO mkdir busco busco -i assembly/ecoli.fasta -l enterobacterales_odb10 -m geno -o ecoli --out_path ./busco/ 10.1.4 Report: MultiQC (change commands) mkdir multiqc cd multiqc mkdir input cp ../quast/report.tsv input/ cp ../busco/ecoli/short_summary.specific.enterobacterales_odb10.txt input/ cp ../prokka/ecoli/ecoli.txt input/ multiqc --cl-config &quot;prokka_fn_snames: True&quot; -o . input/* firefox multiqc_report.html MultiQC modules: https://multiqc.info/docs/#multiqc-modules "],["11-Cleanup.html", "Chapter 11 Cleanup 11.1 quast 11.2 busco 11.3 checkm 11.4 racon 11.5 All prokkas files are useful 11.6 tar", " Chapter 11 Cleanup Like to remove intermediary files that are not needed. We could delete all the directories apart from final assembly however we will delete files that are definitely not needed, leaving files that we may want to use again (assembly fasta files, stats etc.). You can delete files you definitely dont need as you go along (recommended for large files or if storage space is a premium) but I tend to do my cleanup at the end of a project. cd ~/bacterial_assembly_standard_workflow du -hsc * ##redbean du -hsc redbean_assembly/* #delete the gzipped files that we will most likely never even look at #always like to ls when using wildcards or deleting directories before deleting to make sure your are not deleting anything you dont want to ls redbean_assembly/gz rm redbean_assembly/gz #delete the index files for the assembly we created for racon polishing ls redbean_assembly/ecoli.ctg.fa. rm redbean_assembly/ecoli.ctg.fa. 11.1 quast Generally quast does not produce large files so we will ignore it here 11.2 busco du -hsc busco/redbean/* rm -r busco/redbean/busco_downloads ls busco/redbean/busco_.log rm busco/redbean/busco_.log du -hsc busco/redbean/ecoli/* ls busco/redbean/ecoli/logs rm -r busco/redbean/ecoli/logs ls busco/redbean/ecoli/prodigal_output rm -r busco/redbean/ecoli/prodigal_output #The below directory may be useful but normally the short summary is sufficient to keep and use ls busco/redbean/ecoli/run_enterobacterales_odb10 rm -r busco/redbean/ecoli/run_enterobacterales_odb10 11.3 checkm du -hsc checkm/redbean/ecoli/* ls checkm/redbean/ecoli/storage rm -r checkm/redbean/ecoli/storage 11.4 racon du -hsc racon/redbean/ecoli/* #delete sam files, these are relatively large ls racon/redbean/ecoli/sam rm racon/redbean/ecoli/sam #index files ls racon/redbean/ecoli/.fasta. rm racon/redbean/ecoli/.fasta. #dnadiff has small files so we will leave alone du -hsc racon/redbean/ecoli/dnadiff* ##circlator du -hsc circlator/redbean_raconi2/ecoli/* #we can delete all the 00-05 files ls circlator/redbean_raconi2/ecoli/0[0-5] rm circlator/redbean_raconi2/ecoli/0[0-5] 11.5 All prokkas files are useful ##I will let you cleanup in the final assembly directory 11.6 tar #Good to tar a directory when not needed any more #Lots of files will slow a cluster a tarred directory will only count as one file #do with a practice directory well make by copying our standard_workflow_directory cd ~/bacterial_assembly cp -r standard_workflow standard_workflor_backup tar -czvf standard_workflow.tar.gz standard_workflor_backup #you can watch as the different files are compressed rm -rf standard_workflow_backup #UNtar tar -xzvf standard_workflow.tar.gz ls standard_workflow_backup "],["12-Appendix.html", "A Next steps B Manuals C Obtaining Read Data", " A Next steps Conda and Mamba are invaluable tools to install programs and create virtual environments. Benchmarks of long-read assemblers paper. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6966772/ B Manuals Conda: https://conda.io/projects/conda/en/latest/user-guide/getting-started.html Mamba: https://github.com/mamba-org/mamba Redbean (wtdbg2): https://github.com/ruanjue/wtdbg2 Bandage: https://rrwick.github.io/Bandage/ GFA spec: http://gfa-spec.github.io/GFA-spec/GFA1.html Canu: https://github.com/marbl/canu HGAP: https://github.com/PacificBiosciences/Bioinformatics-Training/wiki/HGAP Flye: https://github.com/fenderglass/Flye Raven: https://github.com/lbcb-sci/raven NECAT: https://github.com/xiaochuanle/NECAT Shasta: https://github.com/chanzuckerberg/shasta FastQC: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/ MultiQC: https://multiqc.info/ Trim Galore: https://www.bioinformatics.babraham.ac.uk/projects/trim_galore/ Bowtie2: http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml samtools: http://www.htslib.org/ BBTools: https://jgi.doe.gov/data-and-tools/bbtools/ Kraken2: https://github.com/DerrickWood/kraken2/wiki/Manual Krona: https://github.com/marbl/Krona/wiki/KronaTools Bracken: https://ccb.jhu.edu/software/bracken/index.shtml?t=manual LEfSe: https://huttenhower.sph.harvard.edu/lefse/ HUMAnN2: https://github.com/biobakery/biobakery/wiki/humann2 MetaPhlAn2: https://huttenhower.sph.harvard.edu/metaphlan2/ Biobakery: https://github.com/biobakery/biobakery MegaHit: https://github.com/voutcn/megahit BWA: https://github.com/lh3/bwa minimap2: https://github.com/lh3/minimap2 MetaBAT2: https://bitbucket.org/berkeleylab/metabat/src/master/ CheckM: https://github.com/Ecogenomics/CheckM/wiki PhyloPhlAn: https://github.com/biobakery/phylophlan/wiki MetaWRAP: https://github.com/bxlab/metaWRAP Pokka: https://github.com/tseemann/prokka MinPath: https://github.com/mgtools/MinPath/blob/master/readme MetaCyc: https://metacyc.org/ C Obtaining Read Data https://github.com/PacificBiosciences/DevNet/wiki/8-plex-Ecoli-Multiplexed-Microbial-Assembly "]]
